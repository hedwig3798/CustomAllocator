# 구현 내용

## 포인터 연산

### 더하기, 빼기

주소 연산을 편하게 하기 위해 주소를 정수로 바꾼 `uintptr_t` 타입을 사용합니다.

간단한 더하기, 빼기 연산은 정수처럼 사용할 수 있습니다.

---

### 정렬

현대 CPU는 4혹은 8바이트로 정렬된 데이터에 대해 연산 능력이 올라갑니다. 

이 때문에 주소를 할당해주기 전, 시작 주소를 정렬해 주는것이 좋습니다.

시작 주소 `ptr` 과, 정렬값 `alignment`가 주어졌을 때 다음과 같습니다.

 `alignment`는 2의 제곱수여 합니다.
 

1. `alignment`에 1을 빼는것으로 `alignment` 의 하위 비트를 1로 만들어 줍니다.
2. `ptr` 이랑 AND 연산을 하는 것으로 `ptr` 이 정렬값에서 얼마나 넘쳐있는지 구합니다.
3. `alignment` 에서 해당 값을 빼는 것으로 `ptr`정렬을 위해 얼마나 더해야 하는지를 구할 수 있습니다. 이를 `adjustment`라 합니다.
4. 만일 `alignment` 이 `adjustment`와 같다면 이미 정렬이 되어 있습니다.

---

몇몇 할당자는 할당 헤더를 두어야 합니다. (스택 할당자 등)

즉 헤더를 위한 공간을 포함하여 정렬을 해주어야 합니다.

1. 기존 방법과 같이 `adjustment`를 구합니다.
2. 만일 `adjustment`값이 헤더의 크기보다 크다면 공간을 굳이 더할 필요는 없습니다.
3. 헤더를 넣기 위한 공간이 더 필요한 경우 헤더 블록이 얼마나 더 들어가야 하는지 구합니다.
    
    $$
    adjustment \ = \ adjustment \ + \ alignment \ \times \ (needSpace \ / \ alignment)
    $$
    
4. 만일 필요한 공간이 `alignment`로 나누어 떨어지지 않는다면 추가로 한블록 공간이 더 필요합니다. 

---

## 스택 할당자

스택 할당자는 스택 메모리와 같은 방식으로 메모리를 할당하고 해제합니다.

스택의 `top` 부터 할당이 되고 해제할 때도 `top` 부터 해제되어야 합니다.

`base` 포인터를 이용하여 마지막으로 할당된 주소를 가지고 있습니다. 이는 할당과 해제의 순서를 보장하기 위해 사용합니다.

---

### 초기화

한번에 많은 크기의 메모리를 할당합니다.

`top` 과 `base`를 할당받은 메모리의 주소로 초기화합니다.

---

### 헤더

할당 정보를 가지고 있는 헤더가 각 노드마다 필요합니다.

헤더에는 다음 정보가 들어가 있습니다.

1. 정렬를 위해 사용한 값
2. 이전 주소 → 스택의 모든 할당과 해제가 보장된다면 불필요합니다.

---

### 할당

1. `top`의 주소를 정렬합니다. 
    1. 이 때 헤더의 크기를 포함한 정렬을 해야 합니다.
2. 정렬된 `top` 주소 값이 최종 반환해야하는 값 `adress`입니다.
3. 헤더가 있는 경우 `adress` 에서 헤더의 크기만큼 뺀 곳을 사용합니다. 그 후 헤더에 정보를 넣습니다.
4. `base` 주소를 `adress`로 최신화 합니다.
5. `top` 주소를 스택의 꼭대기, `adress` + 할당된 크기 로 최신화 합니다.

---

### 해제

1. 해제 요청을 받은 포인터를 `ptr`이라 합니다.
2. `ptr`과 `base`를 비교하고, 다르다면 해제 요청을 무시합니다.
3. 헤더의 정보에서 이전 `base` 포인터를 가져와 최신화합니다.
4. `top` 주소를 `ptr`과 `ptr`에 저장되어있는 정렬값을 이용해 스택의 꼭대기로 옮깁니다.

---

## 리스트 할당자

하나의 큰 노드를 가지고 있다가 할당 요청이 들어올 때 필요한 만큼 노드를 쪼개 할당해줍니다.

쪼개진 각 노드들은 리스트 형태로 연결되어 있습니다.

노드를 선택하는 방법으로 총 2가지 방법을 구현하였습니다.

---

### 초기화

한번에 많은 양의 메모리를 미리 할당합니다.

처음에는 모든 메모리 영역을 한 노드로 관리합니다.

메모리의 시작부분을 `freeNodeHead`에 저장하여, 리스트의 시작점을 명시합니다.

---

### 할당

최초 적합 할당, 최적 적합 할당 2가지 종류가 있습니다.

각 방법은 할당 할 노드를 찾는 과정이 다르고, 나머지는 같습니다.

---

1. 최초 적합 할당
    1. `freeNodeHead`부터 순차로 노드를 탐색합니다.
    2. 해당 노드 크기가 할당이 가능하다면 바로 할당합니다.
    3. 탐색이 빠르지만, 내부 단편화 위험이 있습니다.
2. 최적 적합 할당
    1. `freeNodeHead`부터 순차로 모든 노드를 탐색합니다.
    2. 찾은 노드 중 할당이 가능하면서 크기가 가장 작은 노드에 할당합니다.
    3. 탐색이 느리지만, 내부 단편화가 가장 적습니다.

---

두가지 방법으로 할당을 할 노드를 찾고 나면 본격적인 메모리 할당을 시작합니다.

할당된 노드의 크기에 따라 두가지 방법으로 노드를 관리합니다.

1. 할당을 한 후의 남은 노드 크기가 작은경우
    1. 내부 단편화를 방지하기 위해 노드 전체를 반환합니다.
    2. 노드간의 연결 고리 확인을 위한 헤더의 값을 이용하여 구현하였습니다.
2. 할당을 한 후의 남은 노드 크기가 충분히 큰 경우
    1. 해당 노드를 할당 할 부분만큼 나누어줍니다.
    2. 할당할 노드를 반환합니다.
    3. 남은 노드는 리스트와 다시 연결시켜 줍니다.

---

### 해제

메모리를 해제하고 다시 리스트와 연결시켜 줍니다.

단 리스트 노드의 순서가 주소의 순서와 동일함을 보장해주어야 합니다.

1. 해제 될 노드의 다음 노드 를 탐색합니다.
    1. `prevNode` : 해제 될 노드의 이전 노드
    2. `currNode` : 해제 될 노드의 다음 노드
2. `prevNode`가 `nullptr`인 경우
    1. 해제 될 노드가 리스트의 헤드가 되어야 합니다.
3. `prevNode`와 해제 될 노드가 붙어있는경우
    1. `prevNode`와 해제 될 노드를 합쳐줍니다.
4. 그외의 모든 경우
    1. `prevNode` 와 `currNode`사이에 해제 될 노드를 넣어줍니다.
5. 리스트의 헤더가 해제 될 노드와 붙어있다면 합쳐줍니다.

---

## 풀 할당자

리스트 할당자와 유사합니다.

대신 모든 노드의 크기가 일정하여 할당과 해제가 매우 빠른 할당자 입니다.

매쉬의 정점과 같이 같은 크기의 데이터가 많이 할당, 해제 될 때 사용하면 좋습니다.

또한 각 노드의 순서를 보장하지 않아도 됩니다.

---

### 초기화

1. 한번에 많은 양의 메모리 공간을 할당합니다.
2. 시작 주소를 정렬합니다. 이렇게 정렬된 주소를 `lisHead`라 합니다.
3. 총 메모리 공간에 입력받은 오브젝트가 몇개까지 들어갈 수 있는지 계산합니다.
4. 해당 크기 만큼 리스트 노드를 생성합니다. 이 때 각 노드의 시작 부분에 다음 노드의 주소를 저장합니다.
    1. 이 때문에 오브젝트의 크기는 포인터 주소의 크기 이상 있어야 합니다
    2. `void*`의 크기보다 작은 객체는 할당 할 수 없습니다.
5. 마지막 노드의 다음 주소는 `nullptr`로 초기화 해줍니다

---

### 할당

1. `lisHead`가 반활될 주소 입니다.
    1. 만일 `listHead`가 `nullptr`이라면 리스트가 가득 차 있는것 입니다.
2. `lisHead` 에 저장되어 있는 다음 주소를 가져와 `listHead`에 저장합니다.

---

### 해제

리스트 노드의 순서를 보장하지 않아도 됩니다. 이 때문에 성능이 리스트 할당자보다 빠릅니다. 

1. 해제할 주소 `ptr` 의 시작부분에 현재 `listhead` 주소를 저장합니다.
2. `listHead`를 `ptr` 값으로 최신화 합니다.
    1. 이 과정을 통해 리스트 구조를 유지하면서 메모리 해제가 가능합니다 

---

# 속도 비교

각 할당자의 속도가 C++의 `new` , `delete`보다 얼마나 효율적인지 속도 측정을 하였습니다.

---

## 측정 방법

각 테스트케이스는 다음과 같습니다.

1. 같은 크기의 메모리 할당
2. 같은 크기의 메모리 할당 및 삭제
3. 다른 크기의 메모리 할당
4. 다른 크기의 메모리 할당 및 삭제

풀 할당자의 경우 특성상 다른 크기 메모리 할당이 불가능하여 3, 4번 테스트 케이스에선 제외되었습니다.

---

## 환경

CPU : AMD Ryzen 5 7500F 6-Core

SSD : Samsung SSD 870 EVO 1TB

GPU : NVDIA GeForce RTX 4060 Ti

IDE : Visual Studio 2022

Language: C++ 17

---

## 결과

### 요약

1. 풀 할당자가 가능한 모든 환경에서 가장 좋은 효율을 보여주었습니다.
    1. 추가 연산이 가장 적기 때문이라 생각합니다.
    2. 대신 정해진 크기만 할당이 가능하다는 단점이 존재합니다.
2. 대체로 디버깅 환경에서 더 좋은 효율을 보여줍니다.
    1. 디버깅 환경에서 `new` `delete` 연산 시 디버깅을 위한 추가적인 작업을 하고 있다 생각합니다.
    2. 그럼에도 불구하고, `Release`에서도 더 좋은 연산 효율을 보여줍니다.

### TC 1

| Debug |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- |
| TC1 | Stack | Pool | List (First Fit) | List (Best Fit) | C++ new |
| AllocateTime | 0.002733 | 0.001307 | 0.003844 | 0.003091 | 0.007735 |
| efficiency | 64.66709761 | 83.10277957 | 50.30381383 | 60.03878474 | 0 |

| Release |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- |
| TC1 | Stack | Pool | List (First Fit) | List (Best Fit) | C++ new |
| AllocateTime | 0.001347 | 0.000202 | 0.001069 | 0.001753 | 0.002605 |
| efficiency | 48.29174664 | 92.24568138 | 58.96353167 | 32.70633397 | 0 |

---

### TC 2

| Debug |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- |
| TC2 | Stack | Pool | List (First Fit) | List (Best Fit) | C++ new |
| AllocateTime | 0.002845 | 0.00125 | 0.003419 | 0.003023 | 0.007197 |
| DeallocateTime | 0.000609 | 0.000484 | 0.000815 | 0.000818 | 0.006573 |
| 　 | 60.46964013 | 82.63165208 | 52.49409476 | 57.99638738 | 0 |

| Release |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- |
| TC2 | Stack | Pool | List (First Fit) | List (Best Fit) | C++ new |
| AllocateTime | 0.001196 | 0.000224 | 0.001106 | 0.001634 | 0.002679 |
| DeallocateTime | 0.000171 | 0.000161 | 0.000235 | 0.000245 | 0.001618 |
| 　 | 55.3564763 | 91.63867115 | 58.71593878 | 39.0070922 | 0 |

### TC3

| Debug |  |  |  |  |
| --- | --- | --- | --- | --- |
| TC3 | Stack | List (First Fit) | List (Best Fit) | C++ new |
| AllocateTime | 0.000365 | 0.000403 | 0.000322 | 0.001589 |
| 　 | 77.02957835 | 74.63813719 | 79.73568282 | 0 |

| Release |  |  |  |  |
| --- | --- | --- | --- | --- |
| TC3 | Stack | List (First Fit) | List (Best Fit) | C++ new |
| AllocateTime | 0.000165 | 0.000202 | 0.000224 | 0.000371 |
| 　 | 55.52560647 | 45.55256065 | 39.62264151 | 0 |

### TC 4

| Debug |  |  |  |  |
| --- | --- | --- | --- | --- |
| TC4 | Stack | List (First Fit) | List (Best Fit) | C++ new |
| AllocateTime | 0.000256 | 0.000461 | 0.000327 | 0.000883 |
| DeallocateTime | 0.000033 | 0.000075 | 0.00008 | 0.000818 |
| 　 | 71.00792752 | 47.79161948 | 62.96715742 | 0 |

| Release |  |  |  |  |
| --- | --- | --- | --- | --- |
| TC4 | Stack | List (First Fit) | List (Best Fit) | C++ new |
| AllocateTime | 0.00017 | 0.000194 | 0.000223 | 0.000328 |
| DeallocateTime | 0.000012 | 0.000023 | 0.000025 | 0.000151 |
| 　 | 48.17073171 | 40.85365854 | 32.01219512 | 0 |

---
